# noinspection PyPep8
# noinspection PyArgumentList

"""
AUTO-GENERATED BY `scripts/generate_protocol.py` using `data/browser_protocol.json`
and `data/js_protocol.json` as inputs! Please do not modify this file.
"""

import logging
from typing import Any, Optional, Union

from chromewhip.helpers import PayloadMixin, BaseEvent, ChromeTypeBase

log = logging.getLogger(__name__)

# ContextId: Context's UUID in string
ContextId = str

# ContextType: Enum of BaseAudioContext types
ContextType = str

# ContextState: Enum of AudioContextState from the spec
ContextState = str

# ContextRealtimeData: Fields in AudioContext that change in real-time. These are not updatedon OfflineAudioContext.
class ContextRealtimeData(ChromeTypeBase):
    def __init__(self,
                 currentTime: Optional['float'] = None,
                 renderCapacity: Optional['float'] = None,
                 ):

        self.currentTime = currentTime
        self.renderCapacity = renderCapacity


# BaseAudioContext: Protocol object for BaseAudioContext
class BaseAudioContext(ChromeTypeBase):
    def __init__(self,
                 contextId: Union['ContextId'],
                 contextType: Union['ContextType'],
                 contextState: Union['ContextState'],
                 callbackBufferSize: Union['float'],
                 maxOutputChannelCount: Union['float'],
                 sampleRate: Union['float'],
                 realtimeData: Optional['ContextRealtimeData'] = None,
                 ):

        self.contextId = contextId
        self.contextType = contextType
        self.contextState = contextState
        self.realtimeData = realtimeData
        self.callbackBufferSize = callbackBufferSize
        self.maxOutputChannelCount = maxOutputChannelCount
        self.sampleRate = sampleRate


class WebAudio(PayloadMixin):
    """ This domain allows inspection of Web Audio API.
https://webaudio.github.io/web-audio-api/
    """
    @classmethod
    def enable(cls):
        """Enables the WebAudio domain and starts sending context lifetime events.
        """
        return (
            cls.build_send_payload("enable", {
            }),
            None
        )

    @classmethod
    def disable(cls):
        """Disables the WebAudio domain.
        """
        return (
            cls.build_send_payload("disable", {
            }),
            None
        )

    @classmethod
    def getRealtimeData(cls,
                        contextId: Union['ContextId'],
                        ):
        """Fetch the realtime data from the registered contexts.
        :param contextId: 
        :type contextId: ContextId
        """
        return (
            cls.build_send_payload("getRealtimeData", {
                "contextId": contextId,
            }),
            cls.convert_payload({
                "realtimeData": {
                    "class": ContextRealtimeData,
                    "optional": False
                },
            })
        )



class ContextCreatedEvent(BaseEvent):

    js_name = 'Webaudio.contextCreated'
    hashable = []
    is_hashable = False

    def __init__(self,
                 context: Union['BaseAudioContext', dict],
                 ):
        if isinstance(context, dict):
            context = BaseAudioContext(**context)
        self.context = context

    @classmethod
    def build_hash(cls):
        raise ValueError('Unable to build hash for non-hashable type')


class ContextDestroyedEvent(BaseEvent):

    js_name = 'Webaudio.contextDestroyed'
    hashable = ['contextId']
    is_hashable = True

    def __init__(self,
                 contextId: Union['ContextId', dict],
                 ):
        if isinstance(contextId, dict):
            contextId = ContextId(**contextId)
        self.contextId = contextId

    @classmethod
    def build_hash(cls, contextId):
        kwargs = locals()
        kwargs.pop('cls')
        serialized_id_params = ','.join(['='.join([p, str(v)]) for p, v in kwargs.items()])
        h = '{}:{}'.format(cls.js_name, serialized_id_params)
        log.debug('generated hash = %s' % h)
        return h


class ContextChangedEvent(BaseEvent):

    js_name = 'Webaudio.contextChanged'
    hashable = []
    is_hashable = False

    def __init__(self,
                 context: Union['BaseAudioContext', dict],
                 ):
        if isinstance(context, dict):
            context = BaseAudioContext(**context)
        self.context = context

    @classmethod
    def build_hash(cls):
        raise ValueError('Unable to build hash for non-hashable type')
