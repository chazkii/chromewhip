# noinspection PyPep8
# noinspection PyArgumentList

"""
AUTO-GENERATED BY `scripts/generate_protocol.py` using `data/browser_protocol.json`
and `data/js_protocol.json` as inputs! Please do not modify this file.
"""

import logging
from typing import Any, Optional, Union

from chromewhip.helpers import PayloadMixin, BaseEvent, ChromeTypeBase

log = logging.getLogger(__name__)
from chromewhip.protocol import browser as Browser
from chromewhip.protocol import network as Network

# StorageType: Enum of possible storage types.
StorageType = str

# UsageForType: Usage for a storage type.
class UsageForType(ChromeTypeBase):
    def __init__(self,
                 storageType: Union['StorageType'],
                 usage: Union['float'],
                 ):

        self.storageType = storageType
        self.usage = usage


# TrustTokens: Pair of issuer origin and number of available (signed, but not used) TrustTokens from that issuer.
class TrustTokens(ChromeTypeBase):
    def __init__(self,
                 issuerOrigin: Union['str'],
                 count: Union['float'],
                 ):

        self.issuerOrigin = issuerOrigin
        self.count = count


class Storage(PayloadMixin):
    """ 
    """
    @classmethod
    def clearDataForOrigin(cls,
                           origin: Union['str'],
                           storageTypes: Union['str'],
                           ):
        """Clears storage for origin.
        :param origin: Security origin.
        :type origin: str
        :param storageTypes: Comma separated list of StorageType to clear.
        :type storageTypes: str
        """
        return (
            cls.build_send_payload("clearDataForOrigin", {
                "origin": origin,
                "storageTypes": storageTypes,
            }),
            None
        )

    @classmethod
    def getCookies(cls,
                   browserContextId: Optional['Browser.BrowserContextID'] = None,
                   ):
        """Returns all browser cookies.
        :param browserContextId: Browser context to use when called on the browser endpoint.
        :type browserContextId: Browser.BrowserContextID
        """
        return (
            cls.build_send_payload("getCookies", {
                "browserContextId": browserContextId,
            }),
            cls.convert_payload({
                "cookies": {
                    "class": [Network.Cookie],
                    "optional": False
                },
            })
        )

    @classmethod
    def setCookies(cls,
                   cookies: Union['[Network.CookieParam]'],
                   browserContextId: Optional['Browser.BrowserContextID'] = None,
                   ):
        """Sets given cookies.
        :param cookies: Cookies to be set.
        :type cookies: [Network.CookieParam]
        :param browserContextId: Browser context to use when called on the browser endpoint.
        :type browserContextId: Browser.BrowserContextID
        """
        return (
            cls.build_send_payload("setCookies", {
                "cookies": cookies,
                "browserContextId": browserContextId,
            }),
            None
        )

    @classmethod
    def clearCookies(cls,
                     browserContextId: Optional['Browser.BrowserContextID'] = None,
                     ):
        """Clears cookies.
        :param browserContextId: Browser context to use when called on the browser endpoint.
        :type browserContextId: Browser.BrowserContextID
        """
        return (
            cls.build_send_payload("clearCookies", {
                "browserContextId": browserContextId,
            }),
            None
        )

    @classmethod
    def getUsageAndQuota(cls,
                         origin: Union['str'],
                         ):
        """Returns usage and quota in bytes.
        :param origin: Security origin.
        :type origin: str
        """
        return (
            cls.build_send_payload("getUsageAndQuota", {
                "origin": origin,
            }),
            cls.convert_payload({
                "usage": {
                    "class": float,
                    "optional": False
                },
                "quota": {
                    "class": float,
                    "optional": False
                },
                "overrideActive": {
                    "class": bool,
                    "optional": False
                },
                "usageBreakdown": {
                    "class": [UsageForType],
                    "optional": False
                },
            })
        )

    @classmethod
    def overrideQuotaForOrigin(cls,
                               origin: Union['str'],
                               quotaSize: Optional['float'] = None,
                               ):
        """Override quota for the specified origin
        :param origin: Security origin.
        :type origin: str
        :param quotaSize: The quota size (in bytes) to override the original quota with.
If this is called multiple times, the overriden quota will be equal to
the quotaSize provided in the final call. If this is called without
specifying a quotaSize, the quota will be reset to the default value for
the specified origin. If this is called multiple times with different
origins, the override will be maintained for each origin until it is
disabled (called without a quotaSize).
        :type quotaSize: float
        """
        return (
            cls.build_send_payload("overrideQuotaForOrigin", {
                "origin": origin,
                "quotaSize": quotaSize,
            }),
            None
        )

    @classmethod
    def trackCacheStorageForOrigin(cls,
                                   origin: Union['str'],
                                   ):
        """Registers origin to be notified when an update occurs to its cache storage list.
        :param origin: Security origin.
        :type origin: str
        """
        return (
            cls.build_send_payload("trackCacheStorageForOrigin", {
                "origin": origin,
            }),
            None
        )

    @classmethod
    def trackIndexedDBForOrigin(cls,
                                origin: Union['str'],
                                ):
        """Registers origin to be notified when an update occurs to its IndexedDB.
        :param origin: Security origin.
        :type origin: str
        """
        return (
            cls.build_send_payload("trackIndexedDBForOrigin", {
                "origin": origin,
            }),
            None
        )

    @classmethod
    def untrackCacheStorageForOrigin(cls,
                                     origin: Union['str'],
                                     ):
        """Unregisters origin from receiving notifications for cache storage.
        :param origin: Security origin.
        :type origin: str
        """
        return (
            cls.build_send_payload("untrackCacheStorageForOrigin", {
                "origin": origin,
            }),
            None
        )

    @classmethod
    def untrackIndexedDBForOrigin(cls,
                                  origin: Union['str'],
                                  ):
        """Unregisters origin from receiving notifications for IndexedDB.
        :param origin: Security origin.
        :type origin: str
        """
        return (
            cls.build_send_payload("untrackIndexedDBForOrigin", {
                "origin": origin,
            }),
            None
        )

    @classmethod
    def getTrustTokens(cls):
        """Returns the number of stored Trust Tokens per issuer for the
current browsing context.
        """
        return (
            cls.build_send_payload("getTrustTokens", {
            }),
            cls.convert_payload({
                "tokens": {
                    "class": [TrustTokens],
                    "optional": False
                },
            })
        )

    @classmethod
    def clearTrustTokens(cls,
                         issuerOrigin: Union['str'],
                         ):
        """Removes all Trust Tokens issued by the provided issuerOrigin.
Leaves other stored data, including the issuer's Redemption Records, intact.
        :param issuerOrigin: 
        :type issuerOrigin: str
        """
        return (
            cls.build_send_payload("clearTrustTokens", {
                "issuerOrigin": issuerOrigin,
            }),
            cls.convert_payload({
                "didDeleteTokens": {
                    "class": bool,
                    "optional": False
                },
            })
        )



class CacheStorageContentUpdatedEvent(BaseEvent):

    js_name = 'Storage.cacheStorageContentUpdated'
    hashable = []
    is_hashable = False

    def __init__(self,
                 origin: Union['str', dict],
                 cacheName: Union['str', dict],
                 ):
        if isinstance(origin, dict):
            origin = str(**origin)
        self.origin = origin
        if isinstance(cacheName, dict):
            cacheName = str(**cacheName)
        self.cacheName = cacheName

    @classmethod
    def build_hash(cls):
        raise ValueError('Unable to build hash for non-hashable type')


class CacheStorageListUpdatedEvent(BaseEvent):

    js_name = 'Storage.cacheStorageListUpdated'
    hashable = []
    is_hashable = False

    def __init__(self,
                 origin: Union['str', dict],
                 ):
        if isinstance(origin, dict):
            origin = str(**origin)
        self.origin = origin

    @classmethod
    def build_hash(cls):
        raise ValueError('Unable to build hash for non-hashable type')


class IndexedDBContentUpdatedEvent(BaseEvent):

    js_name = 'Storage.indexedDBContentUpdated'
    hashable = []
    is_hashable = False

    def __init__(self,
                 origin: Union['str', dict],
                 databaseName: Union['str', dict],
                 objectStoreName: Union['str', dict],
                 ):
        if isinstance(origin, dict):
            origin = str(**origin)
        self.origin = origin
        if isinstance(databaseName, dict):
            databaseName = str(**databaseName)
        self.databaseName = databaseName
        if isinstance(objectStoreName, dict):
            objectStoreName = str(**objectStoreName)
        self.objectStoreName = objectStoreName

    @classmethod
    def build_hash(cls):
        raise ValueError('Unable to build hash for non-hashable type')


class IndexedDBListUpdatedEvent(BaseEvent):

    js_name = 'Storage.indexedDBListUpdated'
    hashable = []
    is_hashable = False

    def __init__(self,
                 origin: Union['str', dict],
                 ):
        if isinstance(origin, dict):
            origin = str(**origin)
        self.origin = origin

    @classmethod
    def build_hash(cls):
        raise ValueError('Unable to build hash for non-hashable type')
