# noinspection PyPep8
# noinspection PyArgumentList

"""
AUTO-GENERATED BY `scripts/generate_protocol.py` using `data/browser_protocol.json`
and `data/js_protocol.json` as inputs! Please do not modify this file.
"""

import logging
from typing import Any, Optional, Union

from chromewhip.helpers import PayloadMixin, BaseEvent, ChromeTypeBase

log = logging.getLogger(__name__)

# BrowserContextID: 
BrowserContextID = str

# WindowID: 
WindowID = int

# WindowState: The state of the browser window.
WindowState = str

# Bounds: Browser window bounds information
class Bounds(ChromeTypeBase):
    def __init__(self,
                 left: Optional['int'] = None,
                 top: Optional['int'] = None,
                 width: Optional['int'] = None,
                 height: Optional['int'] = None,
                 windowState: Optional['WindowState'] = None,
                 ):

        self.left = left
        self.top = top
        self.width = width
        self.height = height
        self.windowState = windowState


# PermissionType: 
PermissionType = str

# PermissionSetting: 
PermissionSetting = str

# PermissionDescriptor: Definition of PermissionDescriptor defined in the Permissions API:https://w3c.github.io/permissions/#dictdef-permissiondescriptor.
class PermissionDescriptor(ChromeTypeBase):
    def __init__(self,
                 name: Union['str'],
                 sysex: Optional['bool'] = None,
                 userVisibleOnly: Optional['bool'] = None,
                 allowWithoutSanitization: Optional['bool'] = None,
                 panTiltZoom: Optional['bool'] = None,
                 ):

        self.name = name
        self.sysex = sysex
        self.userVisibleOnly = userVisibleOnly
        self.allowWithoutSanitization = allowWithoutSanitization
        self.panTiltZoom = panTiltZoom


# BrowserCommandId: Browser command ids used by executeBrowserCommand.
BrowserCommandId = str

# Bucket: Chrome histogram bucket.
class Bucket(ChromeTypeBase):
    def __init__(self,
                 low: Union['int'],
                 high: Union['int'],
                 count: Union['int'],
                 ):

        self.low = low
        self.high = high
        self.count = count


# Histogram: Chrome histogram.
class Histogram(ChromeTypeBase):
    def __init__(self,
                 name: Union['str'],
                 sum: Union['int'],
                 count: Union['int'],
                 buckets: Union['[Bucket]'],
                 ):

        self.name = name
        self.sum = sum
        self.count = count
        self.buckets = buckets


class Browser(PayloadMixin):
    """ The Browser domain defines methods and events for browser managing.
    """
    @classmethod
    def setPermission(cls,
                      permission: Union['PermissionDescriptor'],
                      setting: Union['PermissionSetting'],
                      origin: Optional['str'] = None,
                      browserContextId: Optional['BrowserContextID'] = None,
                      ):
        """Set permission settings for given origin.
        :param permission: Descriptor of permission to override.
        :type permission: PermissionDescriptor
        :param setting: Setting of the permission.
        :type setting: PermissionSetting
        :param origin: Origin the permission applies to, all origins if not specified.
        :type origin: str
        :param browserContextId: Context to override. When omitted, default browser context is used.
        :type browserContextId: BrowserContextID
        """
        return (
            cls.build_send_payload("setPermission", {
                "permission": permission,
                "setting": setting,
                "origin": origin,
                "browserContextId": browserContextId,
            }),
            None
        )

    @classmethod
    def grantPermissions(cls,
                         permissions: Union['[PermissionType]'],
                         origin: Optional['str'] = None,
                         browserContextId: Optional['BrowserContextID'] = None,
                         ):
        """Grant specific permissions to the given origin and reject all others.
        :param permissions: 
        :type permissions: [PermissionType]
        :param origin: Origin the permission applies to, all origins if not specified.
        :type origin: str
        :param browserContextId: BrowserContext to override permissions. When omitted, default browser context is used.
        :type browserContextId: BrowserContextID
        """
        return (
            cls.build_send_payload("grantPermissions", {
                "permissions": permissions,
                "origin": origin,
                "browserContextId": browserContextId,
            }),
            None
        )

    @classmethod
    def resetPermissions(cls,
                         browserContextId: Optional['BrowserContextID'] = None,
                         ):
        """Reset all permission management for all origins.
        :param browserContextId: BrowserContext to reset permissions. When omitted, default browser context is used.
        :type browserContextId: BrowserContextID
        """
        return (
            cls.build_send_payload("resetPermissions", {
                "browserContextId": browserContextId,
            }),
            None
        )

    @classmethod
    def setDownloadBehavior(cls,
                            behavior: Union['str'],
                            browserContextId: Optional['BrowserContextID'] = None,
                            downloadPath: Optional['str'] = None,
                            eventsEnabled: Optional['bool'] = None,
                            ):
        """Set the behavior when downloading a file.
        :param behavior: Whether to allow all or deny all download requests, or use default Chrome behavior if
available (otherwise deny). |allowAndName| allows download and names files according to
their dowmload guids.
        :type behavior: str
        :param browserContextId: BrowserContext to set download behavior. When omitted, default browser context is used.
        :type browserContextId: BrowserContextID
        :param downloadPath: The default path to save downloaded files to. This is requred if behavior is set to 'allow'
or 'allowAndName'.
        :type downloadPath: str
        :param eventsEnabled: Whether to emit download events (defaults to false).
        :type eventsEnabled: bool
        """
        return (
            cls.build_send_payload("setDownloadBehavior", {
                "behavior": behavior,
                "browserContextId": browserContextId,
                "downloadPath": downloadPath,
                "eventsEnabled": eventsEnabled,
            }),
            None
        )

    @classmethod
    def cancelDownload(cls,
                       guid: Union['str'],
                       browserContextId: Optional['BrowserContextID'] = None,
                       ):
        """Cancel a download if in progress
        :param guid: Global unique identifier of the download.
        :type guid: str
        :param browserContextId: BrowserContext to perform the action in. When omitted, default browser context is used.
        :type browserContextId: BrowserContextID
        """
        return (
            cls.build_send_payload("cancelDownload", {
                "guid": guid,
                "browserContextId": browserContextId,
            }),
            None
        )

    @classmethod
    def close(cls):
        """Close browser gracefully.
        """
        return (
            cls.build_send_payload("close", {
            }),
            None
        )

    @classmethod
    def crash(cls):
        """Crashes browser on the main thread.
        """
        return (
            cls.build_send_payload("crash", {
            }),
            None
        )

    @classmethod
    def crashGpuProcess(cls):
        """Crashes GPU process.
        """
        return (
            cls.build_send_payload("crashGpuProcess", {
            }),
            None
        )

    @classmethod
    def getVersion(cls):
        """Returns version information.
        """
        return (
            cls.build_send_payload("getVersion", {
            }),
            cls.convert_payload({
                "protocolVersion": {
                    "class": str,
                    "optional": False
                },
                "product": {
                    "class": str,
                    "optional": False
                },
                "revision": {
                    "class": str,
                    "optional": False
                },
                "userAgent": {
                    "class": str,
                    "optional": False
                },
                "jsVersion": {
                    "class": str,
                    "optional": False
                },
            })
        )

    @classmethod
    def getBrowserCommandLine(cls):
        """Returns the command line switches for the browser process if, and only if
--enable-automation is on the commandline.
        """
        return (
            cls.build_send_payload("getBrowserCommandLine", {
            }),
            cls.convert_payload({
                "arguments": {
                    "class": [],
                    "optional": False
                },
            })
        )

    @classmethod
    def getHistograms(cls,
                      query: Optional['str'] = None,
                      delta: Optional['bool'] = None,
                      ):
        """Get Chrome histograms.
        :param query: Requested substring in name. Only histograms which have query as a
substring in their name are extracted. An empty or absent query returns
all histograms.
        :type query: str
        :param delta: If true, retrieve delta since last call.
        :type delta: bool
        """
        return (
            cls.build_send_payload("getHistograms", {
                "query": query,
                "delta": delta,
            }),
            cls.convert_payload({
                "histograms": {
                    "class": [Histogram],
                    "optional": False
                },
            })
        )

    @classmethod
    def getHistogram(cls,
                     name: Union['str'],
                     delta: Optional['bool'] = None,
                     ):
        """Get a Chrome histogram by name.
        :param name: Requested histogram name.
        :type name: str
        :param delta: If true, retrieve delta since last call.
        :type delta: bool
        """
        return (
            cls.build_send_payload("getHistogram", {
                "name": name,
                "delta": delta,
            }),
            cls.convert_payload({
                "histogram": {
                    "class": Histogram,
                    "optional": False
                },
            })
        )

    @classmethod
    def getWindowBounds(cls,
                        windowId: Union['WindowID'],
                        ):
        """Get position and size of the browser window.
        :param windowId: Browser window id.
        :type windowId: WindowID
        """
        return (
            cls.build_send_payload("getWindowBounds", {
                "windowId": windowId,
            }),
            cls.convert_payload({
                "bounds": {
                    "class": Bounds,
                    "optional": False
                },
            })
        )

    @classmethod
    def getWindowForTarget(cls,
                           targetId: Optional['Target.TargetID'] = None,
                           ):
        """Get the browser window that contains the devtools target.
        :param targetId: Devtools agent host id. If called as a part of the session, associated targetId is used.
        :type targetId: Target.TargetID
        """
        return (
            cls.build_send_payload("getWindowForTarget", {
                "targetId": targetId,
            }),
            cls.convert_payload({
                "windowId": {
                    "class": WindowID,
                    "optional": False
                },
                "bounds": {
                    "class": Bounds,
                    "optional": False
                },
            })
        )

    @classmethod
    def setWindowBounds(cls,
                        windowId: Union['WindowID'],
                        bounds: Union['Bounds'],
                        ):
        """Set position and/or size of the browser window.
        :param windowId: Browser window id.
        :type windowId: WindowID
        :param bounds: New window bounds. The 'minimized', 'maximized' and 'fullscreen' states cannot be combined
with 'left', 'top', 'width' or 'height'. Leaves unspecified fields unchanged.
        :type bounds: Bounds
        """
        return (
            cls.build_send_payload("setWindowBounds", {
                "windowId": windowId,
                "bounds": bounds,
            }),
            None
        )

    @classmethod
    def setDockTile(cls,
                    badgeLabel: Optional['str'] = None,
                    image: Optional['str'] = None,
                    ):
        """Set dock tile details, platform-specific.
        :param badgeLabel: 
        :type badgeLabel: str
        :param image: Png encoded image.
        :type image: str
        """
        return (
            cls.build_send_payload("setDockTile", {
                "badgeLabel": badgeLabel,
                "image": image,
            }),
            None
        )

    @classmethod
    def executeBrowserCommand(cls,
                              commandId: Union['BrowserCommandId'],
                              ):
        """Invoke custom browser commands used by telemetry.
        :param commandId: 
        :type commandId: BrowserCommandId
        """
        return (
            cls.build_send_payload("executeBrowserCommand", {
                "commandId": commandId,
            }),
            None
        )



class DownloadWillBeginEvent(BaseEvent):

    js_name = 'Browser.downloadWillBegin'
    hashable = ['guid', 'frameId']
    is_hashable = True

    def __init__(self,
                 frameId: Union['Page.FrameId', dict],
                 guid: Union['str', dict],
                 url: Union['str', dict],
                 suggestedFilename: Union['str', dict],
                 ):
        if isinstance(frameId, dict):
            frameId = Page.FrameId(**frameId)
        self.frameId = frameId
        if isinstance(guid, dict):
            guid = str(**guid)
        self.guid = guid
        if isinstance(url, dict):
            url = str(**url)
        self.url = url
        if isinstance(suggestedFilename, dict):
            suggestedFilename = str(**suggestedFilename)
        self.suggestedFilename = suggestedFilename

    @classmethod
    def build_hash(cls, guid, frameId):
        kwargs = locals()
        kwargs.pop('cls')
        serialized_id_params = ','.join(['='.join([p, str(v)]) for p, v in kwargs.items()])
        h = '{}:{}'.format(cls.js_name, serialized_id_params)
        log.debug('generated hash = %s' % h)
        return h


class DownloadProgressEvent(BaseEvent):

    js_name = 'Browser.downloadProgress'
    hashable = ['guid']
    is_hashable = True

    def __init__(self,
                 guid: Union['str', dict],
                 totalBytes: Union['float', dict],
                 receivedBytes: Union['float', dict],
                 state: Union['str', dict],
                 ):
        if isinstance(guid, dict):
            guid = str(**guid)
        self.guid = guid
        if isinstance(totalBytes, dict):
            totalBytes = float(**totalBytes)
        self.totalBytes = totalBytes
        if isinstance(receivedBytes, dict):
            receivedBytes = float(**receivedBytes)
        self.receivedBytes = receivedBytes
        if isinstance(state, dict):
            state = str(**state)
        self.state = state

    @classmethod
    def build_hash(cls, guid):
        kwargs = locals()
        kwargs.pop('cls')
        serialized_id_params = ','.join(['='.join([p, str(v)]) for p, v in kwargs.items()])
        h = '{}:{}'.format(cls.js_name, serialized_id_params)
        log.debug('generated hash = %s' % h)
        return h
