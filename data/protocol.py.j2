# noinspection PyPep8
# noinspection PyArgumentList

"""
AUTO-GENERATED BY `scripts/generate_protocol.py` using `data/browser_protocol.json`
and `data/js_protocol.json` as inputs! Please do not modify this file.
"""

import logging
from typing import Any, Optional, Union

from chromewhip.helpers import PayloadMixin, BaseEvent, ChromeTypeBase

log = logging.getLogger(__name__)

{%- set py_types = dict(boolean='bool', integer='int', number='float', string='str', any='Any', object='dict', binary='str') -%}

{# TODO: find a way not to leak id here #}
{%- macro get_py_type(prop) -%}
    {%- if prop.type is defined -%}
        {%- if prop.type == 'array' -%}
            {%- set t =  prop['items']['$ref'] -%}
            {%- if t in py_types -%}
                [{{ py_types[prop['items']['$ref']] }}]
            {%- else -%}
                [{{ prop['items']['$ref'] }}]
            {%- endif -%}
        {%- else -%}
            {{ py_types[prop.type] }}
        {%- endif -%}
    {%- elif prop['$ref'] is defined -%}
        {{ prop['$ref'] }}
    {%- else -%}
        # ERROR: cannot find type for {{ prop }}
    {%- endif -%}
{%- endmacro %}

{% for dependency in domain.dependencies %}
from chromewhip.protocol import {{ dependency | lower }} as {{ dependency }}
{% endfor %}

{% for type_obj in domain.types %}
# {{ type_obj.id }}: {{ type_obj.description | replace('\n', '') }}
{% if type_obj.type == 'object' %}
class {{ type_obj.id }}(ChromeTypeBase):
    def __init__(self
    {%- if type_obj.properties is undefined -%}
        ):
    {%- else -%},
    {% for prop in type_obj.properties | selectattr('optional', 'undefined') %}
                 {{ prop.name }}: Union['{{ get_py_type(prop) }}'],
    {% endfor %}
    {% for prop in type_obj.properties | selectattr('optional', 'equalto', False) %}
                 {{ prop.name }}: Union['{{ get_py_type(prop) }}'],
    {% endfor %}
    {% for prop in type_obj.properties | selectattr('optional', 'equalto', True) %}
                 {{ prop.name }}: Optional['{{ get_py_type(prop) }}'] = None,
    {% endfor %}
                 ):
    {% endif %}

    {% if type_obj.properties is undefined %}
        pass
    {% endif %}
    {% for prop in type_obj.properties %}
        self.{{ prop.name }} = {{ prop.name }}
    {% endfor %}

{% elif type_obj.type == 'py_chrome_identifier' %}
class {{ type_obj.id }}(str):
    def __eq__(self, other):
        print('type of other = %s ' % type(other))
        if not isinstance(other, {{ type_obj.id[:-2] }}):
            return super().__eq__(other)
        return other.id_ == self.__str__()
{% else %}
{{ type_obj.id }} = {{ type_obj.type }}
{% endif %}

{% endfor %}
class {{ domain.domain }}(PayloadMixin):
    """ {{ domain.description }}
    """
    {% if domain.commands is undefined -%}
    pass
    {% else %}
    {% for c in domain.commands %}
    @classmethod
    def {{ c.name }}(cls
        {%- set indent_len = c.name | length + 1-%}
        {%- if c.parameters is undefined -%}
        ):
        {%- else -%},
        {% for p in c.parameters | selectattr('optional', 'undefined') %}
        {{ p.name | indent(indent_len, True) }}: Union['{{ get_py_type(p) }}'],
        {% endfor %}
        {% for p in c.parameters | selectattr('optional', 'equalto', False) %}
        {{ p.name | indent(indent_len, True) }}: Union['{{ get_py_type(p) }}'],
        {% endfor %}
        {% for p in c.parameters | selectattr('optional', 'equalto', True) %}
        {{ p.name | indent(indent_len, True) }}: Optional['{{ get_py_type(p) }}'] = None,
        {% endfor %}
        {{ "):" | indent(indent_len, True) }}
        {%- endif %}

        """{{ c.description }}
        {% for p in c.parameters %}
        :param {{ p.name }}: {{ p.description }}
        :type {{ p.name }}: {{ get_py_type(p) }}
        {% endfor %}
        """
        return (
            cls.build_send_payload("{{ c.name }}", {
            {# as there are no null types, send_payload will remove any null values #}
            {% for p in c.parameters %}
                "{{ p.name }}": {{ p.name }},
            {% endfor %}
            }),
            {% if c.returns is defined %}
            cls.convert_payload({
            {% for r in c.returns %}
                "{{ r.name }}": {
                    "class": {{ get_py_type(r) }},
                    "optional": {{ r.optional is defined and r.optional }}
                },
            {% endfor %}
            })
            {% else %}
            None
            {% endif %}
        )

    {% endfor %}
    {% endif %}
{% for event in domain.events %}


class {{ event.py_class_name }}(BaseEvent):

    js_name = '{{ domain.domain | capitalize }}.{{ event.name }}'
    hashable = {{ event.hashable }}
    is_hashable = {{ event.is_hashable }}

    def __init__(self
    {%- if event.parameters is undefined -%}
        ):
    {%- else -%},
    {% for prop in event.parameters | selectattr('optional', 'undefined') %}
                 {{ prop.name }}: Union['{{ get_py_type(prop) }}', dict],
    {% endfor %}
    {% for prop in event.parameters | selectattr('optional', 'equalto', False) %}
                 {{ prop.name }}: Union['{{ get_py_type(prop) }}', dict],
    {% endfor %}
    {% for prop in event.parameters | selectattr('optional', 'equalto', True) %}
                 {{ prop.name }}: Union['{{ get_py_type(prop) }}', dict, None] = None,
    {% endfor %}
                 ):
    {%- endif %}

    {% if event.parameters is undefined %}
        pass
    {% endif %}
    {% for prop in event.parameters %}
        if isinstance({{ prop.name }}, dict):
            {{ prop.name }} = {{ get_py_type(prop) }}(**{{ prop.name }})
        self.{{ prop.name }} = {{ prop.name }}
    {% endfor %}

    {% if event.is_hashable %}
    @classmethod
    def build_hash(cls, {{ ", ".join(event.hashable) }}):
        kwargs = locals()
        kwargs.pop('cls')
        serialized_id_params = ','.join(['='.join([p, str(v)]) for p, v in kwargs.items()])
        h = '{}:{}'.format(cls.js_name, serialized_id_params)
        log.debug('generated hash = %s' % h)
        return h
    {% else %}
    @classmethod
    def build_hash(cls):
        raise ValueError('Unable to build hash for non-hashable type')
    {% endif %}
{% endfor %}
